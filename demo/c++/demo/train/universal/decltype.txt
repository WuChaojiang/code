//******************************************************************************
//
// RTTI:运行时类型识别，在泛型的编程中使用。因为非泛型编程时，类型是明确的。
// typeid(x).name()         可知道类型名称
// typeid(x).hash_code()    可比较变量的类型，动态时得到的信息
// is_same模板函数的成员类型value在编译时所得的信息

// 会产生一些运行时开销，编译器默认是关闭该特性的：GCC:-fno-rttion XLC/C++:-qnortti
// 微软编译器：/GR-


// typeid(x)返回的是type_info类型
// 


// 利用decltype推导类型，再利用using来为类型取名。可提高代码的可读性和可维护性
// 利用decltype可以重用匿名类型

使用匿名的理由一般是程序员不希望匿名后的类型被重用

decltype一个最大的用途就是用在追踪返回类型的函数中

当使用模板时，有些不能够满足时，需要写特殊版本。

decltype只能够接受表达式做参数


result_of:基于decltype用于推导函数的返回类型

std::result_of 模板参数只能是函数指针类型，函数引用类型,function-like class(仿函数类)三者之一;
不能是函数类型,函数数类型是不具有调用call特性的. 
result_of内部是把函数调用拆成函数类型和函数参数两部分处理的