Java核心技术 卷1 基础知识
传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了过程，就要开始考虑存储数据的方式。算法第一，数据结构第二
OOP将数据放在第一位，然后再考虑操作数据的算法

OOP特征：
类
封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。
对象中的数据称为实例域，操作数据的过程称为方法。
对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。
程序仅通过对象的方法与对象数据进行交互。
可通过扩展一个类来建立另一个新的类。这个过程称为继承

对象的三个特征：
对象的行为：有方法定义
对象的状态：通过方法调用而改变
对象的标识：作为一个类的实例，每个对象的标识永远是不同的（如订单，任何两个订单都存在不同之处）

识别类：
识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
所谓“找名词与动词”原则只是一种经验

封装的优点：
访问器可以改变内部实现，除了该类的方法之外，不会影响其他代码。
更改器可以执行错误检查，而直接对域进行赋值将不会进行这样的处理。

注意不要编写返回引用了可变对象的访问器方法。
如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。
对象clone是指存放在另一个位置上的对象副本。
凭经验可知，若果需要返回一个可变数据域的拷贝，就应该用clone。

基于类的访问权限：
一个方法可以访问“所属类的所有对象的私有数据”。C++和Java都一样。

final实例域
final修饰符大都应用于基本类型域，或不可变类的域。
（若果类中的每个方法都不会改变其对象，这种类就是不可变的类。String就是不可变的类）
对于可变的类，使用final修饰符可能会对读者造成混乱。

静态域
在绝大多数的面向对象程序设计语言中，静态域被称为类域。术语“static”只是沿用了C++的叫法，并无实际意义。
静态变量使用的比较少，但静态常量却使用得比较多。比如：System.out，就是一个多次使用的静态常量，它是类域。
最好不要将域设计为Public，然而，公有常量（即final域）却没有问题。
本地方法可以绕过Java语言的存取控制机制。在自己编写程序时，不应该这样处理。

静态方法
是一种不能向对象实施操作的方法。但是可以用对象调用静态方法。但容易混淆，建议使用类名调用静态方法。

Java程序设计语言对对象采用的不是引用调用，实际上，对象引用进行的是值传递。
总结：Java程序设计语言中方法参数（这里值输入参数）的使用情况：
1.一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）
2.一个方法可以改变一个对象参数的状态
3.一个方法不能让对象参数引用一个新的对象


异常、断言、日志和调试
异常：可能会出现的错误和问题，哪些类问题需要关注
1.用户输入错误：如url等
2.设备错误：如打印机过程中没有纸了，打印机关掉了，网页可能临时性不能浏览
3.物理限制：磁盘满了
4.代码错误：程序方法可能无法正确执行

在方法中抛出（throw）一个封装了错误信息的对象，这个方法会立刻退出，并不返回任何值。
Error：Java运行时系统内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象
如果出现这样的内部错误，除了通知用户并尽力使程序安全得终止之外，再也无能为力。这种情况很少见。
Exception：需要关注，分两支，RuntimeException和包含其他异常
由程序错误导致的异常属于：RuntimeException
程序本身没有问题，有像I/O错误这类问题导致的异常属于其它异常（即IOException）。
RuntimeException有几种情况：
1.错误的类型转换
2.数组访问越界
3.访问空指针

其它异常：
1.试图在文件尾部后面读取数据
2.试图打卡一个不存在的文件
3.试图根据给定的字符串查找Class对象，而这个字符串表示的类并不存在。

未检查异常：Error或RuntimeException类的所有异常
已检查异常：其它的异常

编译器将核查是否为所有的已检查异常提供异常处理器。
实际上，现在讨论的所有错误都发生在运行时（RuntimeException）。

在自己编写方法时，不必将所有可能抛出的异常都进行声明。什么时候必须使用throws子句声明，需要牢记4种情况：
1.调用一个抛出已检查异常的方法，例如：FileInputStream构造器
2.程序运行过程中发现错误，并且利用throw语句抛出一个已检查异常
3.程序出现错误，例如数组越界
4.Java虚拟机和运行时库出现的内部错误
1、2：必须告诉调用方法可能抛出异常
对于那些可能被他人使用的Java方法，应根据异常规范，在方法的首部声明这个方法可能抛出的异常，若多个用逗号隔开。
不应该声明从RuntimeException继承的那些未检查异常

GC：垃圾回收
一个对象被回收, 必须满足两个条件: 1)没有任何引用指向它 2)GC被运行。
WeakReference的一个特点是它何时被回收是不可确定的, 因为这是由GC运行的不确定性所确定的.
所以, 一般用weak reference引用的对象是有价值被cache, 而且很容易被重新被构建, 且很消耗内存的对象.









































































